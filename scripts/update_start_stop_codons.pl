#!/usr/local/bin/perl
use strict;
use DBI;
use lib ($ENV{EUK_MODULES}, $ENV{EGC_SCRIPTS});
use Egc_library;
use Data::Dumper;
use Gene_obj;
use DBmodel_to_geneobj;


my $usage = "$0 -d <database> -f <extend_orf.pl_output_file> -p pwdfile -o <UNDO_file>[-F force_update_despite_5/3prime_partial_status [F] -n <number_of_supportive_evidence [0]> -S T/F update_ONLY_successes [T] -debug T/F [F] -verbose T/f [F]]\n\n";
$usage .= <<_DESC;

Description:

	update_start_stop_codons.pl takes the  output file  generated by  extend_orf_devel_3.pl and 
	updates the coordinates for every gene model (ONLY successful ones by default) and  creates 
	an undo file to revert the changes.
	
	This program  DOES  NOT  update the  model and protein sequences and therefore update_seq.pl 
	should be run to modify those entries.
	
	After the updates, all UTRs from modified end5 and end3 models are removed. 
	
_DESC

my %arg = @ARGV;
die $usage if $ARGV[0] eq '-h' or scalar(@ARGV) == 0;
my $db   = $arg{-d} || die $usage;
my $undofile = $arg{-o} || die $usage;
my $file = $arg{-f} || die $usage;
my $support_ev = $arg{-n} || 0;
my $DEBUG = $arg{-debug} || 'F';
my $VERBOSE = $arg{-verbose} || 'F';
my $SUCCESS = $arg{-S} || 'T';
my $FORCE_PARTIAL = $arg{-F} eq 'T' ? 'T':'F';
my ($num_ATG_changes, $num_STOP_changes, $total_genes) = (0,0,0);

my ($user,$pass);
if ($arg{-p}){
		open(PWD,"<$arg{-p}") || die "ERROR, I cannot open $arg{-p}: $!\n";
		($user, $pass) = (<PWD>);
		chomp $user;
		chomp $pass;
		close PWD;
}
else {
	die $usage;
}


my ($dbproc) = &ConnectToDb("SYBTIGR","Sybase",$user,$pass, $db);
($dbproc->{AutoCommit},$dbproc->{RaiseError})=(0,1);

open(FHI, "<$file") || die "I cannot open $file: $!\n\n";
open(UNDO,">$undofile") || die "I cannot write $undofile: $!\n\n"; 
while(<FHI>){
	chomp;
	
	next unless m/^\d+\.t\d+/; ## skip blank, comment and error lines
	
	print "\n*** NEW UPDATE = $_\n" if $DEBUG eq 'T' or $VERBOSE eq 'T';

	my ($tu_feat_name,$type,$strand,$end5,$end3,$modify,$success) = split m/,/;
	
	next unless ($tu_feat_name && $type && $strand && $end5 && $end3 && $modify && $success);
	## skip gene if modify tag is not set to 1
	next if $modify != 1;
	
	## skip gene if success tag is not set to 1
	if ($success != 1 && $SUCCESS eq 'T'){
		print STDERR "WARNING, Skeeping ( $_ ) => NOT SUCCESSFUL EXTENSION\n";
		next;
	}
	
	$total_genes++;
	
	my $gene_data = &get_gene_info($dbproc, $tu_feat_name,$strand);
	
	## Create gene object
	my $gene_obj = &DBmodel_to_geneobj::get_gene($dbproc, $gene_data->{m_feat_name});
	my ($first_exon_obj, $last_exon_obj) = &get_start_end_exons ($gene_obj);
	my ($first_CDS_obj, $last_CDS_obj) = &get_start_end_cds ($first_exon_obj, $last_exon_obj);

	
	my %evidence  = &get_evidence_info ($dbproc, $tu_feat_name,$strand);
	
	## Estimate how many gene finders support the new end5 start codon
	#print "$tu_feat_name,$type,$strand,$end5,$end3,$modify", Dumper($gene_data)."\n".Dumper(\%evidence)."\n\n";
	my ($counter, $old_counter) = (0,0);
	foreach my $ev_end5 (keys %evidence){
		$counter++ if $evidence{$ev_end5} == $end5;
		$old_counter++ if $evidence{$ev_end5} == $gene_data->{m_end5};
	}
	print "\nSupportive evidence for new end5 ($end5)= $counter and for current end5 ($gene_data->{m_end5})= $old_counter\n" if ($type eq 'ATG');
	
	
	## Updating end5 end of genes
	if ( ($counter >= $support_ev) and ($type eq 'ATG') ){ ## everything looks fine....so modify end5 if there is enough evidence
			
		## Skip end5 update if gene is 5' partial
		if ($gene_obj->is_5prime_partial() && $FORCE_PARTIAL eq 'F'){
			print STDERR "** Skipping, $gene_data->{tu_feat_name}. 5' partial\n";
		}
		else {	
			print "\nOLD GENE OBJECT:\n".$gene_obj->to_GFF3_format() if $DEBUG eq 'T' or $VERBOSE eq 'T';
			
			## Update TU end5
			print "Updating $gene_data->{tu_feat_name} end5 from $gene_data->{tu_end5} to $end5\n";
			&update_end5 ($dbproc, $gene_data->{tu_feat_name},$end5,$gene_data->{tu_end5});

			
			## Update model end5
			print "Updating $gene_data->{m_feat_name} end5 from $gene_data->{m_end5} to $end5\n";
			&update_end5 ($dbproc, $gene_data->{m_feat_name},$end5,$gene_data->{m_end5});


			## Update exon end5
			my $old_e_end5 = $first_exon_obj->{end5};
			print "Updating $first_exon_obj->{feat_name} end5 from $old_e_end5 to $end5\n";
			&update_end5 ($dbproc, $first_exon_obj->{feat_name},$end5,$old_e_end5);
			$first_exon_obj->set_coords($end5,$first_exon_obj->{end3});
			
			## Update CDS end5
			my $old_CDS_end5 = $first_CDS_obj->{end5};
			print "Updating $first_CDS_obj->{feat_name} end5 from $old_CDS_end5 to $end5\n\n";
			&update_end5 ($dbproc, $first_CDS_obj->{feat_name},$end5,$old_CDS_end5);
			$first_CDS_obj->set_coords($end5,$first_CDS_obj->{end3});
			
			## Update gene_obj coords
			$gene_obj->refine_gene_object();
			print "\nNEW GENE OBJECT:\n".$gene_obj->to_GFF3_format() if $DEBUG eq 'T' or $VERBOSE eq 'T';
			
			print UNDO "$tu_feat_name,$type,$strand,$gene_data->{tu_end5},$end3,$modify\n";
			$num_ATG_changes++;
		}
	}
	elsif ($type eq 'ATG'){
		print "** Skipping $gene_data->{tu_feat_name}. Not enough supporting evidence ($counter)\n\n";
	}

	## Updating end3 end of genes
	if ( $type eq 'STOP' ){ 
			
		## Skip end3 update if gene is 3' partial
		if ($gene_obj->is_3prime_partial() && $FORCE_PARTIAL eq 'F'){
			print STDERR "** Skipping, $gene_data->{tu_feat_name}. 3' partial\n";
		}
		else {	
			print "\nOLD GENE OBJECT:\n".$gene_obj->to_GFF3_format() if $DEBUG eq 'T' or $VERBOSE eq 'T';

			## Update TU end3
			print "Updating TU: $gene_data->{tu_feat_name} end3 from $gene_data->{tu_end3} to $end3\n";
			&update_end3 ($dbproc, $gene_data->{tu_feat_name},$end3,$gene_data->{tu_end3});
			
			## Update model end3
			print "Updating model: $gene_data->{m_feat_name} end3 from $gene_data->{m_end3} to $end3\n";
			&update_end3 ($dbproc, $gene_data->{m_feat_name},$end3,$gene_data->{m_end3});


			## Update exon end3
			my $old_e_end3 = $last_exon_obj->{end3};
			print "Updating exon: $last_exon_obj->{feat_name} end3 from $old_e_end3 to $end3\n";
			&update_end3 ($dbproc, $last_exon_obj->{feat_name},$end3,$old_e_end3);
			$last_exon_obj->set_coords($last_exon_obj->{end5},$end3);
			
			## Update CDS end3
			my $old_CDS_end3 = $last_CDS_obj->{end3};
			print "Updating CDS: $last_CDS_obj->{feat_name} end3 from $old_CDS_end3 to $end3\n\n";
			&update_end3 ($dbproc, $last_CDS_obj->{feat_name},$end3,$old_CDS_end3);
			$last_CDS_obj->set_coords($last_CDS_obj->{end5},$end3);
			
			## Update gene_obj coords
			$gene_obj->refine_gene_object();
			print "\nNEW GENE OBJECT:\n".$gene_obj->to_GFF3_format() if $DEBUG eq 'T' or $VERBOSE eq 'T';
			
			print UNDO "$tu_feat_name,$type,$strand,$end5,$gene_data->{tu_end3},$modify\n";
			$num_STOP_changes++;
		}
	}
}

print "Total number of ATG changes supported by at least $support_ev gene finders = $num_ATG_changes\n";
print "Total number of STOP additions = $num_STOP_changes\n";
print "Number of skip genes without enough evidence = ".($total_genes-$num_ATG_changes-$num_STOP_changes)."\n\n";
close UNDO;
close FHI;


#######################################################################
sub get_start_end_exons {
	my $gene_obj = shift;
	my @exons = &Gene_obj::get_exons( $gene_obj );
	return ($exons[0], $exons[ $#exons ]);
}

sub get_start_end_cds {
	my ($first_exon_obj, $last_exon_obj) = @_;
	my $first_CDS_obj = $first_exon_obj->get_CDS_obj();
	my $last_CDS_obj = $last_exon_obj->get_CDS_obj();
	return ($first_CDS_obj,$last_CDS_obj);
}

sub get_gene_info {
	my ($dbproc, $tu_feat_name,$strand) = @_;
	my $desc = '';
	if ($strand eq '-'){
		$desc = ' desc'; 
	}
	
	my @results;
	my $query = "select t.feat_name,t.end5,t.end3,m.feat_name,m.end5,m.end3
				from asm_feature t, asm_feature m, phys_ev p, feat_link
				where t.feat_name=parent_feat
				and child_feat=m.feat_name
				and m.feat_name=p.feat_name
				and t.feat_type='TU'
				and m.feat_type='model'
				and p.ev_type='working'
				and t.feat_name=\"$tu_feat_name\"
				order by m.end5 $desc
				 ";
	eval { @results = &do_sql($dbproc, $query)  ; };
	if($@){
        print "**ERROR getting gene info from $tu_feat_name\n";
    }
	
	my @first_exon = split m/\t/, $results[0];
	return { 	tu_feat_name 	=> $first_exon[0],
				tu_end5 		=> $first_exon[1],
				tu_end3 		=> $first_exon[2],
				m_feat_name 	=> $first_exon[3],
				m_end5 			=> $first_exon[4],
				m_end3 			=> $first_exon[5],
	};
}

sub get_evidence_info {
	my ($dbproc, $tu_feat_name,$strand) = @_;
	my (@results,%gene_finder);
	my $query = "
				SELECT p.ev_type, a.end5
				FROM phys_ev p, asm_feature a, feat_link
				WHERE parent_feat=\"$tu_feat_name\"
				AND child_feat=a.feat_name
				AND child_feat=p.feat_name
				AND a.feat_type = 'model'
				AND p.ev_type != 'working'
				";
	eval { @results = &do_sql($dbproc, $query)  ; };
	if($@){
        print "**ERROR getting evidence info from $tu_feat_name\n";
    }
	foreach my $result (@results){
		my @evidence = split m/\t/, $result;
		$gene_finder{$evidence[0]} = $evidence[1];
	}
	return %gene_finder;
}

sub	update_end5 {
	my ($dbproc, $feat_name,$end5,$old_end5) = @_;
	my $query = "UPDATE asm_feature
				SET end5 = $end5
				FROM asm_feature
				WHERE feat_name=\"$feat_name\"
				AND end5 = $old_end5
				";
	eval {
		print "$query\n" if $DEBUG eq 'T';
		my $row = $dbproc->do($query) if $DEBUG eq 'F';
		if ($row == 1){	
			$dbproc->commit();
			print "Commiting....$feat_name\n";
		} 
		else {
			$dbproc->rollback();
			print "Rolling back $feat_name because of number of rows to modify = $row\n";
		} 
	};
	if($@){
        print "** ERROR updating end5 info from $feat_name:\n";
		print "$DBI::lasth->errstr\n";
		print "$DBI::lasth->{Statement}\n";
    	$dbproc->rollback();
    }

}

sub	update_end3 {
	my ($dbproc, $feat_name,$end3,$old_end3) = @_;
	my $query = "UPDATE asm_feature
				SET end3 = $end3
				FROM asm_feature
				WHERE feat_name=\"$feat_name\"
				AND end3 = $old_end3
				";
	eval {
		print "$query\n" if $DEBUG eq 'T';
		my $row = $dbproc->do($query) if $DEBUG eq 'F';
		if ($row == 1){	
			$dbproc->commit();
			print "Commiting....$feat_name\n";
		} 
		else {
			$dbproc->rollback();
			print "Rolling back $feat_name because of number of rows to modify = $row\n";
		} 
	};
	if($@){
        print "** ERROR updating end3 info from $feat_name:\n";
		print "$DBI::lasth->errstr\n";
		print "$DBI::lasth->{Statement}\n";
    	$dbproc->rollback();
    }

}

